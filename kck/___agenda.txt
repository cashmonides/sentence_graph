Agenda (updated jan 1, 2017)
- MISSION CRITICAL
    - revert to development_status = release

FUTURE DESIDERATA
- development_status that reads URL
- messages from your teacher button (great job! it looks like you beat 9 levels. OR you seem to be starting games and abandoning them. Is there any way I can help?
- english block of text (paraphrase or translation) with word missing - read latin text - answer structural questions - fill in blank
    - e.g. Draco was king of _____ / Vulcan is the god of ________


-----------------------CURRENT AGENDA--------------------------------



---spelling bee operations---



GET 

get seen

get unseen but usable words/roots
    get allowed roots from module
    generate allowed words from allowed roots
    filter out seen words and seen roots
    output --> unseen_words_list & unseen_roots_list


TRANSFORM DATA


---step 1---
produce total_desired of each category

---step 2---
sort: for seen items read parameter from module and either (shuffle || sort from lowest || sort from highest)
 

---step 3---
concatenate by consulting the weighting (x, y, z)
    e.g. targeted: 80, unseen: 20, untargeted: 0
    
    e.g. targeted: 60, unseen: 20, untargeted: 20 
    
   

    


desiderata

    **
        
    if insufficient, get words outside range
        calculate mastery score's distance from center of visibility range (returns a number)
    
    **shuffle outside-range-words in each distance category
    
    **pick n number of items from shuffled list (n = target - within-range-words)




example:
    [0.3-0.5]
    respects-the-user-wishes:
    sort from highest: 0.4, 0.3, 0.7*, 0.1*, -3*
    sort from lowest: 0.3, 0.4, -3*, 0.1*, 0,7*
    shuffle: 0.4, 0.3, 0.35, -3*, 0.1*, 0.7*


output --> map of lists

e.g. {

	words: [str, str, str, str, ...], 

	roots: [str, str, str, str, ...]

}





INTERNAL BOOKKEEPING

initialize quiz.current_indices (at 0)  

initialize quiz.word_scores_update_list (as {})







PREP FOR PICKING

determine question_type by weighted choice from module > etymology_level

determine desired_item_type (word or root) from question_type





PICK

pick word from quiz.available_words_and_root_list (based on quiz.current_indices)





(PROCESS ANSWER)





UPDATE INTERNAL METRICS

make item to put in quiz.word_scores_update_list

    item(str): {

        word: str,              //e.g. 'arthropod'

        type: str,              //'word' || 'root'

        correct_on_first: bool,

        max_attempts_reached: bool,

        attempts_made: int,

        hints_received: int

    }

    

push item to quiz.word_scores_update_list



INTERNAL BOOKKEEPING

increment quiz.current_indices.word or quiz.current_indices.root



PERSIST

iterate over quiz.word_scores_update_list

for each item: 

	do GET operation

	alter GET result

	SET with altered result



CALLBACK

when all operations are finished run whatever comes next (e.g. next_submodule/submodule_complete/return_to_profile)


--------------------------------------------------------------------------------

"FINISHING" SPELLING BEE
- *bad-data-detector routine for etymology data
- *persistence of word data in firebase and sql
- *weighted choosing of words from persisted word data
- *mirror mode (play a previous result)
- *display of known and less known words (a personal dictionary)
- *display personal results (division + ranking)
- talk to defense against the "hit the enter button ten times trick"


- ^^^^ password protect in-class spelling bee making ability
- ^^^^ return the third column and put a heading at each (hero, titan, olympian)
- ^^^^ add button for spelling bee at home mode (click on division and level, autogenerate pin, log score)
- ^^^^ check hint behavior (why is it showing a hint penalty?)
- ^^^^ change display to include and embolden top 4, possibly add a hero/titan/olympian icon
- ^^^^ add span bold words in hint

- mid-term
    - change hint behavior when levels advance
        - 1-200 no penalty
        - 200-400 small penalty for underscore hint
        - 400-600 big penalty for underscore hint
        - 600-800 small penalty for any hint
        - 800-900 big penalty for any hint
        - 900-1000 no hints at all
    - add question type field (e.g. morphology, latin, grammar etc.)
    
    
    
    
- down the road
    - identical words mode (true spelling bee matchup)
    - specific root in training mode (e.g. can choose queen or -fy)



- chores:
    - add words & slideshow for next three weeks
        - phobia
        - ology & onomy
        - cracy & archy
        - terr & aqu/hydr & pyr/ign & vent/aer
    - slideshow on heros titans and olympians



- online chores:
    - add bee pictures up to 200
    








-------------------------------------------------------------------------------








PERSISTENCE OF INDIVIDUAL-WORD DATA

final answer:
    data structure looks like this:
        key: a number (e.g. .7 or .754)
        value: a word (e.g. arthropod, which points to an object word, definition, roots, etc.)
    persist statement looks ike this:
        correct --> increase both x and y field
        incorrect ---> increase y field
        

questions:
	where do we store the data?
		- firebase
		- sql
2 choices:
	- unseen word
	- seen word
		- preferences
			- low total
			- low quotient

// ideal # of times X happens before we reduce its occurences
imagine:
x-ideal = factor


john johnson: {
	word_accuracy: {
		arthropod: [4, 10],          // -1/10
		pedestrian: [98, 101],       // 93/101
		phlebotomy: [1, 1] ,          // -4
        podium: [20, 25]			// 15/25 = 3/5
        herbivore: [5, 5]			// 0
        old carnivore: [10, 10]         // 5/10 = 1/2
        carnivore: [30, 35]         // 25/35 = 5/7
	},
	root_accuracy: {

	}
}



pick seen or unseen (weighted)



if seen,
if seen is empty

if seen is initialized
go to firebase
choose_seen



persist.set (new entry for word)







DATASTRUCTURE


-9
-8
-7
-6
-5
-4
-3
-2
-1
0
.1
.2
.3
.4
.5
.6
.7 {
	0.75: [arthropod, 4, 10]
}
.8
.9





key: knowledge_weighting (e.g. .75)
value: string, x, y

knowledge/weighting = ideal#-x/y
x = number of correct 
y = number of attempts


.75 ---



arthropod: [4, 10],          
		93/101: pedestrian: [98, 101],       
		-4: phlebotomy: [1, 1] ,          
        3/5: podium: [20, 25]			
        0: herbivore: [5, 5]			
        1/2: old carnivore: [10, 10]         
        5/7: carnivore: [30, 35]         





IN PROGRESS
- root dictionary
    - button on quiz page (visible only in etymology, spelling and spelling match mode)
    - toggles
    - displays root + derivative words
        - ___ARTHR___
        - arthropod - an invertebrate with jointed legs
        - arthritis - inflammation
        - arthroscope - 
    - possible malicious hack:
        - user gets the question: spell the word that means "invertebrate with jointed legs"
        - clicks on root dictionary button
        - searches for "invertebrate with jointed..."
        - cuts and pastes answer into input box
        - possible solution:
            - allow this behavior in initial levels
            - as score progresses, the definitions disappear
            - click on definition but only with a penalty





ALERT MISSION CRITICAL





IMMEDIATE PRIORITY
- word-knowledge parameter
- enter grades
- make sure modules are set up for week 1 spelling match testing
- create more users for spelling bee testing
- time control solo play (mirror mode)
- bug: "I will have loved" appeared in morphology level 240
- make sure number of spelling hint cheat sheet dummies is set in all modules
- Akiva ask Dan
    - what is the meaning of the following in quiz:
        - el('spelling_hint_button_master').onclick = this.initialize_spelling_hint_master.bind(this);


DA.PUZZLES
- mutate random characteristic
- replace root
- convert word to x and non-x
- 


????AS QUESTIONS FOR DAN????
- why is the string prototype not working


PERSIST ACCURACY ON INDIVIDUAL WORDS
- this should be roughly how it works as a SQL command
    
    UPDATE TheTable SET RevisionId = RevisionId + 1 WHERE Id=@id\
- explanation:
    UPDATE <name of table>
    SET id = id + 1
    WHERE id = <name of id>  
    
- fields
    - userid (primary key)
    - word/root (string)
    - question type (could be an integer enumeration)
    - correct count (int - initialized at 0)
    - incorrect count (int - initialized at 0)
    - threshold for incorrect (i.e. 7 attempts max)  (int)


ATTACK PLAN FOR SPELLING BEE
_____DO NOW_____
- chore-like
    - clear console logs, especially ones that give answers
    - set up levels for matches
    - set up dictionary of levels
    - set up root progression
    - build bee level to 1000
    - add bee pictures
    - build up dictionary of levels
    - use dan's range sampler
- OFFLINE CHORE-LIKE
    - add words
    - add spans
    - add roots
    - find and add example sentences
    - add bee pictures
    - add images to modules that don't have them
- ONLINE CHORE-LIKE
    - get bee pictures
    - pictures for etymology slide shows
    - get images for animals that are missing
- CODING CHORE-LIKE
    - clean up logs 
        - build up fronstage logs and backstage logs
        - convert all console.logss
    
- MODULE CHORES
    - set a more gradual ascent of level


- SLIDESHOW CHORES
    - word of the day slideshow

- SUPER IMPORTANT
    - switch firebase

- NEW QUESTION TYPES
    - an example sentence with a query word
        - prompt: this word has been flagged by some librarians as properly spelled but others have flagged this as misspelled
        - hint -> highlights the word
        - (normal hint progression to get the proper spelling)
        - when spelled properly, a set of potential definitions comes up
        - again: "some librarians have flagged this as...others as..."
        - user chooses the proper definition
    - type in your definition
        - hints:
            - "four" "foot" 
            - what part of speech it is
            - used in a sentence
        - might have to run it through a profanity detector
        - check for inclusion of key words
            - if it contains the key words it passes, with minimal point gain
        - once it passes a basic check, it's compared side by side with the dictionary definition
            - words that occur in both definitions are green
            - maybe 
        - their definition is stored in firebase
        - later they are presented with the same question
            - this time, their current definition is compared side-by-side with their last definition
        - at some point the master user checks all definitions and tags them as good or bad 
            - if they are tagged as bad, that user has to keep answering that question

- ONLINE CHORES
    - create user accounts with avatars

- OFFLINE CHORES
    - add words
    - color avatars
 
- WITH DAN
    - test most recent update with tie detector
    - develop a match_score between two strings
        - if the correct definition is "a vehicle with two wheels"
        - and the user inputs "something with two wheels"
        - the user should get a match score of 3
        - or alternately:
            - two and wheels both have spans around them
            - if they match those they get two points
        - maybe like this:
            - they're given both versions side by side
            - they have to keep revising their version until it reaches a threshold
            - perhaps a somewhat mysterious threshold
            - big points for the two embedded spans
            - extr
    - conceptualize a captcha functionality


    
- small things
    - connect tie-detection algorithm to the ranking system
    - test single root mode in spelling bee and spelling match
    - fix input definition mode
    - create a field in initialize user with avatar
    - add etymology to spelling bee mode and test thoroughly
    - fy/fic/fiction slideshow
        stupefy & stultify
        magnify
        petrify
        classify
        specify
        mortify (draco est mortuus)
        
    - add skip functionality to spelling and spelling match mode
    - persist skips
    - Mr. Darriea letter
    - produce a list of all avatar combos
    - write a unit test that checks if avatars exist
    
    - letter to Ms. C and Mr. Dascal
    - make slideshow presentation for Ms. C.
    
    - finalize avatars
    
    - make_game button should clear the score display
    - remove duplicates from spelling_match_mode.js
    - test an avatar display on admin
    - get silhouettes for missing animals
    - persist win/place/show for spelling bee match games
    - make a lock button (lock spelling bee, lock module, lock avatar generation, etc)
    - write code to build book of roots
    - refactor temporary_incorrect_streak
    - hide hint and everything else when drone game ends
    - increase submodule threshold slightly
    - freeze out behavior of countdown bar temporarily
    - fix countdown bar with Dan
    - start to build in hint penalties at higher levels (but leave disabled)
    - check if metrics are fully disabled for spelling bee
    - pull out the beecatcher into an overall function if possible
    - solve mystery of the visible spans
    - backstage tester for etymology data
        - find words that don't contain root
        - find words whose roots don't match anything on the root list
    - organize admin to output by grade and in order of highest module reached and highest accuracy
    - feedback in morphology and etymology should repeat question
    - move development_status to module
    - divide roots and words into separate files
- medium things
    - add misspelled word in the library functionality
    - persist in user profile # of win/place/shows in spelling match
    - autogenerate html elements with a colored border and animal sillhouette inside
    - hint penalty
    - add synonym functionality
        - short term: give each root & word a synonym field
        - longer term: 
            - each root should be a list of all synonyms
            - with subcategorization as to language
            - e.g. ped/pod/pus
            - e.g. quart / quad / quadr
    - add word difficulty level functionality
    - turn number of drop downs into a module-specified parameter
    - tweak display of etym cheat sheet 
        - turn etym cheat sheet into 2 columns
        - etymology cheat sheet left item (e.g. word) should be bold
    - add example sentence functionality
        - e.g. "The ________ usually have exoskeletons and are carnivorous"
        - e.g. "One example of an ________ is the beetle"
        - select a root of the highlighted word "most ARTHROPODS begin life as an egg" 
        - choices: arth / vert / ped / mono
        - semi-automated in sites such as http://sentence.yourdictionary.com/
        - e.g. 
        - select the definition of the root ARTHR
        - example sentence: "All arthropods are invertebrates but not all invertebrates are arthropods"
        - or
        - example sentence: "Despite the remarkable variety of arthropod species, 
                all share aspects of a single basic body plan. 
                All arthropods possess a stiff exoskeleton composed primarily of chitin." 

    - different kinds of hints
        - contains these letters (they disappear as you spell the word)
            - e.g. spell the WORD that means an invertebrate with JOINted LEGs
            - contains these words A D H O P R T
    - new question type (biPED vs. flipPED)
        - i.e. distinguish between root and non-root substring
        - e.g. all of the following words contain the letters PED
        - click on the word that has the root PED = foot
    - add picture to gallery everytime they win a submodule
    - there should be an easier kind of cheat sheet called something like root + word list
        - the hint looks like this:
        - ROOT: [words_with_root]   // some dummies included
        - e.g. spell the word that means "animal with jointed legs"
        - click hint
        - displayed on screen: 
        - ARTHR: arthritis, arthroscope (the real item)
        - IN: invisible, invertebrate, immutable  (a dummy item)
        - PED/POD: pedestrian, arthropod, pseudopod (the real item)
        - POLY: polyglot, polychrome (a dummy item)
        - etc.
    - make a "set module" secret access button in profile
    

- big things
    - write etymology and spelling results to sql
        - c.execute c.execute(string, table)
    - deterministic questions for spelling match mode
    - generalize match mode to things besides spelling
    - turn etymology drop down into a clickable word selector
    - new mode:
        - reading comprehension THEN etymology
        - read the following sentence (an example sentence from etymology data)
        - then click on whether you think it's true, false or you don't know
        - the sentence is e.g. true
        - now do etymology exercise on the highlighted word
    - at some point the notion of magical spells should appear (pun on the word spell)
    
    - in quick mode, add "find N subjects" functionality
        - using the same sentence the following steps:
        - "in the following sentence, click on at least 3 subjects"
        - then "now click on at least 2 objects"
        - then "what is the root of the highlighted word"
        - then "what tense is the highlighted verb"
        - then "is the highlighted word active or passive"
    
    - convert etymology words to x.y.z format
        - quadruped --> quadr.u.ped
        - with categories   
            - root
            - formation element
            - connector element (e.g. vowel between roots)
            - unknown
        - e.g. 
        - root.connector.root  (quadr.u.ped)
        - root.formation (herb.al)
        - root.root.formation.formation (bin.ocul.ar.s)
        (obviously if we don't know how to classify an element or its data hasn't been
         loaded then we would need to classify it as unknown)
         - e.g. perhaps we don't know what to make pusill. in pusill.anim.ous
            it would end up as unknown.root.formation
        - the utility of this would be:
            - to display a word in x.y.z form could serve as a sort of hint
            - they see quadruped
            - it's confusing
            - they hit hint
            - the word gets turned into quadr.u.ped
            - with the quadr and ped in bold or otherwise graphically distinguished
            - they hit a second layer of hint and it tells them the meaning of the roots quadr and ped
    - build up new dictionary traverser model

    - in quick mode, add some sentences that are both english and latin
        - e.g. 
        - click on 2 verbs (in english and latin)
        - aliis volat propriis
        - she flies with her own wing
        - or e.g.
        - click on the subject in the latin sentence
        - Veritas vos liberabit
        - the truth shall set you free
        - in quick mode, add "find N subjects" functionality
    


________MAPPING CONTROL FLOW AND REFACTORING________
- map the overall flow
    - login -> profile -> quiz
- divide into game engine and display engine
- map the basic quiz flow
    - decision tree for different options
        - e.g. process correct process incorrect submodule complete check for rollover etc.
- refactor quiz
- move a lot of the things in lib to utils
    - e.g. make.js


____BEEBUGS_____
- MILLI seems to be lingering hidden somewhere
- BIO also seems to be hiding urgent log_error initiated root not found in roots: BIO
- upper case words crash
    - short term: november, mesoamerica, december, paleolithic turned to lower case
    - at some point go through control flow and add tolowercase where appropriate


______ADD TO NOTES___________
the saga of adding a game mode
create a STRING name for the mode in the mode itself
go to module.js
add STRING to game_mode_list
link STRING to INT in game_mode_map
add new scr file to INDEX of quiz.js
in quiz.js add map from INT to STRING to Quiz.get_modema


_______BUGS_________
- in inflect_latin dashes vs. !dashes does not seem to be working 
    - (not hugely consequential but should be gotten to the bottom of)
    - akiva added a global hack to make the dashes work in both drop down answer and student's answer
        remove_dashes_global_hack
- test implicit latin   
    - above latin_level 220 there's a bug, probably tied to either
    - the switch to implicit latin or the mixture of implicit and explicit
    - the message is: initiated TypeError: Cannot read property 'j' of undefined

______DATA SCRAPING______
- theoi.com
- sheri amsel exploring nature
- http://sentence.yourdictionary.com/
- etymonline


_______CALENDAR__________
JAN-FEB
persist spelling bee stats better
build spelling bee with nicky stats
parallel-shadow nicky
create slideshow carrot/stick structure for tag and lls (spelling bee winners can win slideshow/movies for their class)
start creating grammar game for pre-mailer
start improving morphology game (stem vowel in grey, sandhi, change ____ to _____ functionality, irregular verbs, chapter by chapter progression, cumulative vs chapter specific mode)
hire ______ for jquery for drop down
hire elizabeth to code syntax for weekend syntax review (possibly redo MF talmud as well and flashcards)
day-by-day playbook
meet with katherine to discuss innovation fatigue
redo mf talmud, caesar talmud, cicero talmud, sallust talmud, vergil talmud, horace talmud

MARCH
build hoplite challenge with nicky stats
parallel-shadow nicky

DEADLINE PRE-VACATION
- grammar game mailer final version for teacher review
- hoplite challenge beta for teacher review
- weekend syntax review beta for teacher review

MAY-AUGUST
implement and monitor hoplite challenge
build a computer representation of all the tasks in the institute (run in office, create demand)
dan passion project hexagon game


SEP-NOV      d3 BOOTCAMP
split cost with mom
go in with extremely specific projects


DEC-MAY
redo website with d3 from scratch
build infinite library hexagon game
identify pain points
study react and other paradigms 
evaluate wisdom of attending full stack
save money






HIGH PRIORITY

- the 9/10 profile bug
    - this bug has been reported by some users but doesn't seem very common
    - its behavior appears to be:
    - when you're at 9/10 and you finish, if you don't hit next level and isntead hit profile  
    - it doesn't register submodule 9 as finished so you return to profile as 9/10
    - i.e. you need to hit next level








    



DESIDERATA

- venn diagrams in words and images
    - given: "All arthropods are invertebrates but not all invertebrates are arthropods"
    - true or false: the spider is an arthropod, therefore it is an invertebrate



SMALLISH ALGORITHM THINGS
- x/y root 2 --> [x, y]   //throwing away 'root 2'
- needs to iterate over all the items in the slash list
- (best to generate a string processor that does this)
- (best to generate a string processor that returns a boolen if x/y/z is in the root)
    - we can use that for matching quad with quad/quadr






LATIN AND KCK AGENDA
step 1
    fix bad macrons and dash removal
        (no bad macrons so far) 
    
    ideally we don't want certain verbs to become passive  
        I am shouted doesn't make a lot of sense
        so we don't want this to be passive except when the mental clause itself is the subject
    important: add scrambling parameter to kck level
        at a higher level of difficulty, we should scramble all the terminal strings in kck drop downs
        (it's a little too easy for more advanced students when it's all lined up)

step 2
    move submit button and cheat sheets to the right (won't overlap with hoverable drop downs) DONE
    tweak drop_levels so that there are more drops
    make kck levels
    proof modules 1-5
    add a lot of intransitive and ditransitive verbs to kck mode
    add a lot of verbs to mcmode
    add english sentences
    make cheat_sheet for dash removal
    


step 3 
    - morphological elements in path name
        - they were loving
        - am / port / vor / port
        - -> a / aba / abi / e / eba / ebi / e / ie / ia / are/ ere / ere
        - -> o s t mus tis nt
    
   
   
   
        -
 


BUGS IN MORPHOLOGY
- feedback should give sentence plus correct answer
- morphology mode is not completing module properly
    - progress is not incremented to 1, stays 0
    - means that user can never improve
- the o/m or/r distinction may not be very clear on the cheat sheet
 
THINGS TO CHECK BEFORE STEP 3.5
    - is ditransitive working properly
    
AKIVA'S QUESTIONS FOR HIS CONTROL FLOW
    maximal_role_to_role_for_verb_restriction?????
    main.js generate_sentence has a simple error catching mode right? (the success variable)
    
  


    
MORPHOLOGY MODE
build the game mode DONE
pipe in lexeme_list DONE
pipe in the shuffle parameter (somewhere in module or morphology_level)
figure out some way to deal with sound changes upon dash removal
enumerate question types (change x to y, form x, etc.)
generate the transformation (maybe generate the kernel and work backwards)
make a submit method (when they've filled all three, the answer is submitted)
    this will increase the speed
fix module_complete
give away answer should contain both english and latin
figure out how to adapt inflect latin for fixed forms with no translation   
    - e.g. present subjunctive
decouple kck and morphology mode
    
step 3.5
    before launching nouns
        map the tribes
        purge the degenerate and unruly tribes
        to test their purity, we enslave them with the following tasks
            produce ind. statement translation formulae and forms
            produce periphrastics at morphology in morphology and kck mode
        remap the purified landscape
        carve the new map into marble
        and place it in the center of the city
    before launching into nouns: make debugging more elegant
        the error logger (which logs in urgent error log) conceals some information
        in development mode we should switch it off
    before launching into nouns: log the relevant info (not a debug log)
        e.g. log what the correct answer is, what lexeme choices we've made
        have it invisible when the development flag is off
    perhaps before making nouns: we make a more elegant dictionary traverser
        - we want a more generalized form of the dictionary traverser
        - goal: get a terminal entry in a dictionary that is buried beneath an arbitrary number of sublevels
          with an arbitrary kind of key
        - i.e. certain triggers (level.basic) dictate certain paths through the dictionary
        - i.e. it seems conceivable that a dictionary interrogator could descend a dictionary
        - at each step it consults a list of relevant properties (terminology.basic, regime.relative)
        - if it matches true it descends that branch, if it matches false it keeps going
        - I imagine an argument structure something like this:
            - let's say we want to get the english translation of the universal tense "imperfect"
            - but the true answer to this may be buried benath a few layes of nesting in the dictionary
            - and the true answer may be subject to a wide range of constraints
        


    
step 4
    make a totally modular way for nouns to be introduced
        completely quarantine all pre-noun steps
        the info that gets sent to the noun-bulding unit should be:
            entirely recoverable from components and/or kernels
            in a very minimalist form
                e.g.
                    subject: true, animate,
                    object: optional
                    implement: false
            feedable into our weighted-allowed in some way:
                e.g. if we've specified that we want explicit: 0.5, implicit: 0.5
        seems like there are three categories of info about each role:
            - possible (e.g. ditransitive verbs and objects)
                outcome would depend on how our randomized interrogation of weighted allowed comes out
            - mandatory (e.g. indirect statements need a noun)
            - forbidden (e.g. certain verbs cannot take an implement *he saw with a sword)
        
        
            
            
SET UP FOR FURTHER STEPS
    walk through control flow for indirect statement
        goal: find hacky parts, pain points, gather info for redesign
        goal: test how nouns can be introduced (indirect statment forces at least one noun to appear)

CLEANUP
- is there a problematic inconsistency in notation (3s vs 3sg)?
    in kck > inflect > inflect_english > inflect_english_verb it says:
    // The person_and_number_key is like 1sg & 3sg.
    // The person_and_number is like 1s.
    what's the point of this?

WALK THROUGH
kck > inflect_language_indepednent > inflectors
kck > inflect_language_indepednent > prune_tf_space

CHECK UP ON OLD TODOs
lib > user.js 
    //todo since we write to firebase in the wrapping function start_module 
    // - shouldn't we skip the following line and just persist there?
    //todo 2-6 akiva's additions, make sure nothing got broken


NEEDS
- security
    - make a captcha for login 
        - (classify photo as animal as biped quadruped arthropod)
        - basic latin translation (e.g. the wolf will love the horses)
        - congratulations! you've demonstrated that you are both a human and a creature that knows latin
        - add a 5 second timeout somewhere in the flow to discourage any bots
    - make a log of anytime there are more than 20 login attempts (i.e. some kind of security log)
    - in the admin page, post any security alerts
    - make a dictionary of jpegs with biped, quadruped, arthropod
        key: wolf1.jpg
        value: biped
    - as well as a list
- a generalized form of the dictionary traverser (also mentioned above)
    - goal: get property from a dictionary that has an arbitrary number of sublevels
      with an arbitrary kind of key
    - i.e. certain triggers (level.basic) dictate certain paths through the dictionary
    - i.e. it seems conceivable that a dictionary interrogator could descend a dictionary
    - at ech step it consults a list of relavent properties (terminology.basic, regime.relative)
    - if it matches true it descends that branch, if it matches false it keeps going
    - I imagine an argument structure something like this:
        - let's say we want to get the english translation of the universal tense "perfect"
        - but the true answer to this may be buried benath a few layes of nesting in the dictionary
        - and the 
        that's subject to some constraints, so
- a testing routine in admin 
    - iterates through every level (kck, etymology etc.)
    - produces 2 things:
        - a sample output (100 outputs)
        - an error status (all is well, fatal error at level 20, sick mode at level 20, 10 or more retries attempted)   
    - would be very useful to do this in etymology (in csv format for easy human-readable conversion)
- we need to decide whether sequence and indicative tenses allowed in kck levels must matches   
    - if we have present_indicative allowed and all sequences we end with source= he ate and choices only include: present indicatives (and no choice offered is correct)
    - weirdly, when sequence = primary and time = simultaenous and indicative tenses allowed = present, then past tenses show up in the drop down choices (he attacked)
    
- at some point - not necesarily soon - terminal string click should serve as submit
    - at more advanced levels that would allow for quicker input and more practice per minutes
    - it would be especially useful in a very targeted mode like morphology mode
    - 
PREREQ


SEEMS TO BE FIXED
- cosmetic: the one-option problem in medial drop down
    - when there's only one option, a nesting drop down level shouldn't be spawned, it should be skipped
    - e.g.:
    - sometimes the range of allowed options is low (i.e. only active not passive)
    - and if voice is part of the drop_down_path
    - we end up with a path like: command / love -> active -> 3s / 3p
    - we don't want the active drop down level to even start

- fix: turn terminology display dictionary on DONE

- small thing: Weird tense: imperfect subjunctive of the active periphrastic active

- fix: vocabulary cheat sheet is not functional in kck mode  

- requisite functionality: dummy agreement marker
    - short term solution: set subject gender as masculine upstream
    - long term solution: set gender based either on gender of noun 
        or on some parameter set module-by-module e.g. subject_gender: ['masculine': 0.3, 'feminine': 0.3, 'neuter': 0.3]



NEEDS TO BE FIXED AS A PREREQ

- potential issue: say vs speak in drop down heading PERHAPS DONE NEEDS CHECKING

- small thing: full text of question should appear in the feedback box DONE

- crucial: was verbing vs verbed needs to be either explained in paper handout/PDF cheat sheet or eliminated!!!!
    - for now: remove perfect tense


- in early stages of kck, passives should be late in the path


    
DESIDERATA BEFORE NOUNS
- if nothing entered in a field when creating account, it should still create a field in firebase (otherwise it messes up and makes the user sick - like beatrice and brandon)





- move to utils:
function add(a, b) {return a + b}


CHORES
- add lots of verb lexemes
- make cheat_sheets (verb charts) for the new conjunctions (e.g. ut = that/in order that)
- add lots of lexemes to mcmode (to stall the students)
- add metacharacters to dashes

COSMETICS

- feedback box could be a better
    - green and red path should not show the final string perhaps, just the path elements that are wrong
- drop down on mouseleave switches to fast  DONE

AS CONTROL FLOW MAPPING TASK
- implement indirect statement conjunction without nouns
    - use it as an opportunity to draw a control flow map between all the different tense maps and tense taxonomies
    - produce a dummy version with no noun (just for testing)
    
    
    
AS DATA-LOGIC CONNECTION TASK
- add to data: 2s, 3s, 3p etc. should have level specific terminology (you, he, they, etc. for more basic levels) 


AS STRING PROCESSING TASK
- figure out where in the control flow we should intervene to drop dashes

- get a dashed version ready for release

- start dash removal
    - adapt the old library for dash removal
    - set the parameter for dashes in modules
    - after dash removal, test ambiguity control



SMALL SEMANTIC ISSUES
vid-ēbā-tur cūr dīx-issē-t = he was being seen why he had spoken 
    - (not great but we can fix when we do gender
    - mental verbs that have a clause as the subject should be neuter


SMALL STRUCTURAL THINGS
some parameters in etymology cheat sheet should be changed from hard-coded to specified by module   
        e.g.
        var question_with_cheat_sheet = make_etymology_question_with_cheat_sheet(
        this.level.etym_level, weighted(this.legal_question_types), 4, 4, 4);


NOT REQUIRED FOR MVP



- ambiguity 
        - convergent ambiguity (two different paths have same terminal string)
            - (-am = future || pres subj)
            - solution: check set of dropdown answers, if a duplicate exists, send an alert "the one you selected is a duplicate answer with x"
            - seems to be fixable with a language-independent solution
        - divergent ambiguity (one origin has two correct divergent paths with different terminal string)
            - ruit = what tense in english?
            - solution: have a catch statement (if two stems are identical in Latin && )
            - seems to be fixable only with a language-specific solution


- non-required functionality: include latin stem in drop down path name



- cosmetics: clarify for students the green and red path    
    - include the question along with the green and red answer
    - include the full drop and non drop in the feedback
        - if the question is VERB CONJUNCTION THEY ATTACK
        - the feedback should be red and green for VERB and CONJUNCTION but include THEY ATTACK in black
    - some sort of symbol for the drop downs
    - correct answer comes first and is big
    - path name comes second and is smaller
    - with some sort of symbol for path
    - such as: AMABANT love->prior->3p
    the green and red path should have some sort of symbole



- check lexicon and avoid transitive verbs that can't lack object
        - say? know? feel? mental verbs seem to either require an object or forbid it
    


- semantic issue:  avoid "I am written"

Agenda for saturday





- give verb information about subject gender and explicitness


PREP-CHORES
- add noun lexemes (AS - DONE)
- add noun drop downs to parameters in allowed (AS - MOSTLY DONE)
- add noun decliner (DS)
    - need to write a function
        - determine_case 
        - arguments: target language, conjunction/direction, role_name
        
KCK GENERATION WITH NOUNS
- produce templates with S V O
- pick lexemes
- lexeme choice of subject determines gender
- set gender of kernel based on noun picked
    - need function: set_gender_of_kernel
- if implicit, choose gender randomly from allowed


START OF MENTAL VERB DIGRESSION

mental verbs have weird rules
examples:
they spoke why he was killed
they were spoken why the mountain is pushed (would make sense as "told", though)
so we have to fix this

also only one answer choice is somewhat awkward

but the noun switch appears to work
its secret is that unless there are nouns, there's no subject and object (in the template)
this might also create issues with "why", since "why" introduces a clause
that acts as an object

since "why" is causing so many issues, one solution would be to just throw it out
but this is somehow unsatisfying


AKIVA'S RESPONSE:
Clearly mental verbs are special in that they can take clauses as subjects and objects.
There are other situations where clauses are subjects and objects (e.g. quod the fact that clause)
At some point in the future we should bring our system into alignment as much as possible with
current linguistic theory, if it's useful.

But for mental verbs we need a short-term solution and a long-term solution.
The short-term solution is necessary during our stalling phase. 
In the stalling phase we just want vcv
and we want indirect statement and indirect question to be functional in the stalling phase

This is what suggests itself to me:

short-term solution:
    - classify speak, say, know, and all mental verbs as intransitive for now
    - or: classify them as clause_transitive (or some similar term) and treat
            all clause_transitive verbs as intransitive

long-term solution:
    - see if any other kinds of verbs besides mental verbs need special treatment
    - (e.g. quod the fact that clause can be subject or object of any verb, not just mental)
    - come up with a classification term that encompasses mental verbs
        - e.g. clause_transitive, complementizer_transitive
    - when we make a template creator, clause_transitive verbs produce a clause_object
       or a clause_subject
   - and of course they don't make a regular noun_object if they make a clause_object
    - (in other words: we develop an information-rich template)
    - we might even call it a mental_clause_object
    
    
    
- with regard to the problem of speak:
    they spoke why he was killed
    they were poken why the mountain is pushed (would make sense as "told", though)
    
    - a quick and dirty option would be to limit dico to clause_transitive and can never be intransitive
    - but this isn't a realistic account of language
    
    - I guess to fully work up a sophisticated model we need to have multiple translations that are dependent on context
    - e.g. dico, dicere = speak, say
    - when intransitive it should be 'speak'
        they spoke
    - when transitive it could be either, but we could just pick one    
        they spoke words = they said words
    - when clause_transitive it should be 'say'
        they said why the mountain was pushed
    - when passive
        intransitive - no passive
        transitive - were spoken (special subjects only, see below)
        clause_transitive - were said
        
- one other point, I've added a category of mental_nouns
    - word, sentence, opinion, etc. are mental_nouns
    - they're not entire clauses of mental verbs
    - but they're the only sensible noun objects of mental verbs
    - *the cow was spoken is ungrammatical
    
END OF AKIVA'S RESPONSE
    
END OF MENTAL VERB DIGRESSION

TAXONOMY OF VERBS
    transitive (aka obligatory transitive) //fill
    intransitive (aka onligatory intransitive)   //sleep
    ditransitive //eat
    mental ditransitive //speak (when intransitive), say (when transitive)
    mental transitive //know
    mental intransitive //ruminate (identical to any intransitive)




DROP DOWN
- add noun drop-down options implementation
  - adapt most of our verb machinery for nouns
  - create a separate drop_down_path for nouns parameter in kck_levels (AS - DONE)
  - noun drop downs probably not nested (though we should build in the possibility just to be consistent)
        - nested behavior probably not useful in english
            (we just want wolf / wolves / lion / lions)
        - but nested behavior could be useful in Latin
            - first level of drop:
                LUP
                URS
                CORV
                LEO/LEON
            - second level of drop
                singular
                plural
            - third level of drop
                LEO
                LEON-IS
                LEON-Ī
                LEON-EM
                LEON-E
            - or (right?)
                LEON-ĒS
                LEON-UM
                LEON-IBUS
                LEON-ĒS
                LEON-IBUS








ADD FUNCTIONALITY
- add subject pronouns in Latin


ONLY AN ISSUE IN IMPLICIT VERB
- parameter in kck_level to set for handling gender in translation
    - call it gender_preference
        'default_he'
        'random_gender'
        'he/she/it'
    - English: 
        he is default
        pick he || she || it 
        'he/she/it'
    - Latin: 
        - option a -us/a/um
        - pick -us || -a || -um
        - option b '-us' is the default or us/a/um
    - suppose the subject options are lupus and regina
        - then to avoid giving away information we need to have both -us and -a (in a periphrastic)
        - but we don't need to have -um (and we might not want to)




MOPPING UP CHORES
- rename drop_down_path to drop_down_path_verb







- it seems like a straightforward process

- one thing to be on the lookout for:
    - we need to choose verb first
    - and that will constrain our noun lexeme choice
    - e.g. certain nouns cannot combine with certain verbs 
        - abstractions can't be objects of certain verbs, etc.
    - we probably need to create some type of verb-noun implications
        - we might want to do something like this in verb lexemes:
            - subject_black_list:
            - object_black_list:
        - e.g.
            - 'throw': {
                object_black_list: [abstraction, location]
            }
        - option 2 would be:
            - create a larger category like physicality/concreteness
            - and this would always exclude abstraction and locatio 
        - e.g.
            - 'throw': {
                lexical properties: [physical]
            }
        - option 1 is more explicit and maybe less liable to lead to vagueness and user error
        - that seems to make sense so maybe we want to use option 1 even though option 2 might be less typing
            - since users can make mistakes and might want to have the information in one place

        - AS: I think in general the option 1 approach is better because we might have verbs
            that occupy gray areas, like rule works nicely with location but not abstraction
            
        - for me the big question that arises:
            - should we also make a white list?
            - like animate for the subject of mental verbs?
            - yes and inanimate for verbs like "lie"  - the rock lies next to the river
            - maybe we could just make it a list of constraints
            - like 'throw': {
                'object_constraints': ['not abstraction', 'not location']
            }
            - 'speak': {
                'subject_constraints': ['animate']
            }
            - 'lie': {
                'subject_constraints': ['not animate']
            }
            
            AS: well a person can lie next to a river (or another person, although we might want a grade-level restriction) ..  but that's just a detail
            yeah ha that's a good point we're gonna have to be careful with the young minds
            
            I don't know about that format. I kind of prefer the white and black list approach
            it seems a little easier to read (yes, it seems to make sense to have more type of data that each do one thing)
            AS: though of course there is the potential for collision
            DS: what type of collision?
            AS: just user error, like if someone was sloppy and put something on both lists
            but I think we can live with that
            we'll never eliminate user error
            DS: we seem to have a potential for this kind of error whatever we do
            AS: so I suggest we implement white and black lists for the following
                (although this is getting a little ahead of ourselves)
                subject
                object
                implement
                recipient
                
              (moving these to semantic notes)
                
            AS: so what else do we need to do before getting started? 
            what other design do we need to carefully deliberate?
            


- DS: fear clauses and mental verbs don't take a (direct) object
    as main verbs introducing is/fear, even though they're transitive
    - I feel pain
    - I fear the wolf
    - I feel that the bird eats the spider (grammatically coherent)
    - I fear that he will go to Rome
    - * I feel pain that the bird eats the spider (not grammatically coherent without apposition)
    - * I fear the wolf that he will go to Rome

- AS: above is a good point. I feel like it's useful for there to be a category called clause
    - so fear   
        object_white_list: [clause, noun]
    - think
        object_white_list: [clause]
        object_black_list: [noun]

- Yes, and a conjunction can force its subordinate clause to be the object of the verb's main clause
    - a rather unrelated issue is that if a verb is passive the subject and object reverse
        - so a sword can be thrown but not throw

    - yes let's talk about how voice plays a role in this
        - it seems like we need voice to be determined before we pick the noun lexeme (which we said we would do)
        - like if we have S V and we don't know the voice then we're in trouble
        - 
            - *the republic is thrown
            - *the sword is thought
            - stuff like that (those aren't very good examples but I can't think of others)
        - it seems to me like we need to use subject restrictions on the object and vice versa

- okay I added voice to the process above
    - we send template, voice boolean, transitivity boolean to lexeme picker
    
- is it worth not making them strictly booleans?
    - like having it be 'transitive' or 'intransitive'?
    - this might allow for more flexibility down the road like double transitive verbs
       - yes it seems to be worthwhile to not just use strict booleans
       - (by the way, I don't actually think double transitive verbs exist
           except insofar as they have an indirect object which has the meaning of a dative)
        - I might not be using the word right but I'm thinking of the double accusative
            - he teaches the children art (two accus objects in latin)
               - Can't we treat the first accusative like a type of dative which happens to be in the accusitive case for some verbs?
                   - because this just means he teaches art to the children
                       - although this does have the issue of not allowing for certain type of passive
                           - I told the king the story
                           - the story was told to the king by me
                           - the king was told the story by me (issue nai
                           vely)
                - yeah maybe that's a good solution
                - I don't know how many double accusatives there are in latin. I have a book at home we can look it up
                - yeah good point, theres some tricky behavior in the passive of double accusatives
                
                
- but let's stay on track. I'll migrate these to advanced semantics
- let's get something basic going
- it seems like subject and object white and black lists are a good started
- shall I start adding white and black lists and you make a template generator?

- yeah let's try to write white/black lists and implement everything until line 31.
   - should we include clauses as objects?
        - yes definitely, there are quite a few cases in latin at least where clauses are objects
    - so do we have to denote this in the conjunction object?
        - i.e., a fear conjunction has some type of difference from 
        - I'm not sure - the conjunction library itself might be powerful enough to handle this
            - it does seem like the conjunction library should handle this or the verb should 
                - it just seems to me like the conjunction should say "I need to be considered the object of my verb"
                    - and in addition have any restriction it might need
                - yeah that seems a good idea
                    - the conjunction could have a property
                        - clause_acts_as_noun
                            (and thus can be subject or object)
                            (and thus no other object possible)
                            (i.e. *he fears the wolf that he will attack)
                        - clause_acts_as_adverb
                            (and thus can't be subject or object)
                            (and thus objects are allowed)
                        - clasue_acts_as_adjective
                            (to be implemented for relative clauses)
                        - I think a clause_acts_as property seems wise.
                            - for all our current conjunctions it would be object or adverb
                            - I don't think it should be noun since that's really more like what happens with a the fact that clause
                        - can act as a noun in the sense that it can be the subject of a passive verb
                            - It just seems like we have to distinguish this from a the fact that clause which can crop up anywhere
                            - by means of the fact that I was prepared, I was able to attack the country
                                - but the fact that is weird and I really don't care whether we call this noun or object
                            - it's a little advanced but:
                                - that he will attack was feared
                                - yes it is the subject there but this only happens with passive verbs
                                - right so it's inaccurate to call it clause acts as object 
                                    (in a sense - it's a small inaccuracy maybe)
                            - so do you have any opinion about "the fact that" or do you want to ignore it for now (which make sense)
                            - I think we should leave it for now. 
                            I want to think about it longer and look up some examples beforehand
                            - seems reasonable
                        - so should it look like this?
                            clause_acts_as: 'noun'   //choices: noun, adverb, adjective (yes that seems fine)
                            let's do that and I'll take account of that in my code (not "adjective" though)
        - the white list in the verb might be redundant
        - the only advantage would be that for certain verbs (like fear)
            - we want to be able to use fear even when we don't have a clause, like he fears the wolf
            - as well as when it gets triggered by the conjunction library (he fears that)
        - maybe it's just the case that we can leave all clause stuff to the conjunction library
        - and fear will get picked

- so how do you want to proceed? here are some agenda items:
    - (yes this seems reasonable)
    - does this seem like a good division of labor?
    - (yes. It seems like the template implications should be part of the template generator, though;
        there aren't that many and it doesn't seem worthwhile to store them as data)
        (okay sounds good. I'll get cracking on my items, sound good?
        (all kck verbs are currently stored in testing kernel library right?)
        (yes that's where the lexicon is stored)
        (okay ill get started)
        are you gonna make template generator in the kck folder? that seems like the place to do it
        yeah if you look you'll see that file
    - add clause_acts_as to conjunctions (AS)
    - add black and white lists to verb lexicon (AS)
    - make set of template implications (DS) (not needed)
        - e.g. transitive implies object
    - make a template generator (DS) (done)
    - make a lexeme picker

- current state
    - everything seems to be going well
    - but we eventually get a mysterious error about mood.
    - which is surprisingly far downstream!

-  seems like much of this should be migrated
    
- down the road
    - design taxonomical object for drop down
    - load taxonomical data
    - morphological path
    - green/red for input mode
  
  
- design filters for ablative and dative semantics with verb    
    - discussion
          but those last two categories are obviously down the road issues
                
                i.e. you can attack with a spear
                so attack has implement with the normal category of implements
                but you can rule with kindness (is this even really implement? are you ruling by means of kindness?)
                    AS: we might want to develop another kind of role that captures this other meaning of with
                    we could call it manner
                    when you conquer someone by means of tears it's an implement
                    so you might be able to conquer someone with pity
                    
                    
                    DS: Yeah that seems like what it is.
                anyway this is getting complicated, we shouldn't worry about it now
                just wanted to bring it up so we're thinking of it
                
                let's not get too lost in the weeds, glad we're thinking about this ahead of time though
                


- profound things that can be delayed without disaster
    - ambiguity resolution and avoidance
    
- cosmetic user experience things
    - drops go up instead of down
    - green/red feebdack should probably go in a different spot
    - better give away answers

- the dropping up instead of down issue
    - possible solution here: 
        - https://www.onedesigns.com/support/topic/how-to-get-the-sub-categories-menu-to-drop-down-instead-of-up


use this for issues

SHORT TERM

- allowed is not controlling drop down parameters
    - drop/non-drop (dan: done)
    - number of dummy options (dan: done)

- finish writing a terminology display dictionary for all languages (excluding relative stuff) (Akiva will do)
  
INTEGRATION
- integrate into quiz and profile

- rename to kck_sentence


- functions that need to be made in KCKMode
    - generate_sentence() 
    - get_text_in_source_language()
    - get_drops_and_non_drops_in_target_language()
    - get_correct_answer_string()
    - check_drop_down_correctness()
    - get_correct_answer_paths()
    
- questions to resolve
    - new name for kck_sentence?

- progress: we're currently getting a display, but it doesn't yet work

  
  
TAXONOMY
- write a taxonomy_level_dictionary

- write a taxonomy JSON object that is testable

- look over taxonomy_level_dictionary for coherence


- send zoological (taxonomy) data to drop downs




LOOSE ENDS
- add relative and absolute time to terminology_display_dictionary (Akiva will do)
- make sure relative and absolute time properly distinguished backstage (Dan should do)





TESTING
- run a bunch of tests, looking for semantic nonsense just in verbs
    - of the sort: "he will be feared that he will attack"


ADD LEXEMES
- add a bunch of verb lexemes
- add more conjunctions to conjunction library
- build in defensiveness, if not enough lexemes exist, then just skip those without crashing


VOCABULARY CHEAT SHEETS
- make vocabulary cheat sheets
- add number of dummy lexemes (by part of speech) to the allowed dictionary


RANGE CAPACITY
- make parameters able to be set as ranges, not just booleans
- import and adapt range-reading functions from previous incarnation


COSMETICS AND CLEAN UP
- investigate lingering drop down bugs
    - maybe use a mouse-over functionality


TESTING
- make many levels (Akiva will do)
- make a button/drop-down/slider to set level - for testing (Dan will do)
- test and catalog nonsense/ambiguity



END OF MVP STAGE FOR LATE SUMMER
////////////////////





MAKE A LIST OF ALL SITUATIONS WHERE AMBIGUITIES ARE RESOLVED BY CONTEXT


AMBIGUITY
- ambiguity resolution
 - two distinct answers with same text
        - ruit (perfect) = ruit (present)
        - leones (nom) = leones (acc)
        - he verbs = more than one path in english
        - lexeme-level phenomenon
        - ideal solution:
            2 kinds of sitation
            - truly ambiguous
                - "correct. It could also be ___other-option-here__"
            - not ambiguous
                - "well... it could be in isolation, but look at the context and fix"
        - stopgap solution:
            - skip fut.1st.sg and pres.subj.1st.sg. in 3rd conj.
 - impossible to determine correct answer with information given (down the road)
        - leones amant duces
            - solution: don't produce the sentence
        - sentence-level phenominon


MORPHOLOGY


- write a dash-removal function
    - adapt from previous incarnation






LONGER TERM

- lexeme is always in english in the drop downs, should also be available in latin


- somehow add morphological data to drop downs 
    - lexeme, principal part, infix, ending
    - attack, oppugnav, era, s -> oppugnav-era-s
    - goal: nested drop down can be used as a latin morphology trainer


////////




randomly generate maximal templates
    aS S gen-S a-gen-S V a-O O with-abl adj-with-abl prep-phrase

randomly fill whole template

remove certain parts of template (replace with none)

add nouns

add swap

add none display

add adjectives







/////////////////


DONE AND OLDER STUFF BELOW



- fix the independent subjunctive bugs (done)

- switch past present future to prior, simultaneous, subsequent in conjunction library (done)

- include conditional type as a clause type (pres ctf, etc.) (done, but was it done in a good way?)

- include independent subjunctive type as a clause type (present deliberative etc.)
(done. but there's one clause type for all independent subjunctives)

- make a conjunction object (seems to be done)

-????: use our dummy lexicon to produce a display
    - dummy lexicon is var testing_kernels in testing_kernel_library

- rebuild lexicon

- plug in our lexicon to the stream

- decide if we want to add sequence property to conditionals
(only an issue to distinguish between flv and pres ctf and e.g. to tell whether we want pluperf subj or perf subj)



What has happened and our plans:




PART 1

STAGE -1
- 1: decide on design rules
- 2: decide on object types

STAGE 0:
- 1: produce blank kernels
- 2: add determistic properties

STAGE 1
- 1: add random properties
- 2: add sequence
- 3: add person and number

(we are here)

STAGE 1.5
- 1: display
- 2: check to make sure we have enough information to make a quiz from this
explanation from Akiva:
i.e. we want to ask about all properties and we want to ask about part of speech
so we just want to make sure that we have all that information and it's easy to access
(we don't need to make the quiz obviously)
What part of speech is the highlighted word?
Is the highlighted word transitive or intransitive?
Is the highlighted word active or passive?


STAGE 2
general note: don't add nouns yet!!!
- 1: instead, feed K C K into our pipeline
question from Dan to Akiva: are we doing this?
- 2: and plug the end result V(with properties) C(with properties) V(with properties)
into a function that inflects English, Latin and SSSLatin
- 3: we already have such functions, we should pull them out into their own files
(inflect_verb.js or something similar) and adapt them as necessary


STAGE 3
- 1: reflect on the process so far
- 2: make any redesign decisions

End of PART 1

PART 2

STAGE 4
- 1: add lexeme choice
- 2: rebuild our verb lexicon

STAGE 5
note: in this stage we have a new MVP
question from Dan: Wasn't stage 4 intended for the same MVP?
- 1: produce sentences of the form:
"you love because we shout"
"he will attack if they shout"
"if they shout, he will attack"
with enough information to make a quiz on all properties, including clause type

End of PART 2



MAKE DROP DOWN FUNCTIONALITY IN BOTH DIRECTIONS






PART 3

STAGE 6 (and maybe more)
- add nouns

...

End of PART 3

(the unknown beyond)

END

Notes:
Why do so much with verbs before adding nouns?
Isn't it descending into the messy reality prematurely?
Shouldn't we just generate purely abstract kernels
with S and O and adjectives first?

Well, maybe. But we have the inflect verb functions pretty well developed
already and it won't take long to chain them up into the pipeline.
The advantage of doing this now is that we will see all the strange things
and weird linguistic realities and bugs and design issues and pain points.
We might learn a great deal and it won't take too long.